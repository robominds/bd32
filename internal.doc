Internal Documentation for BD32
===============================
April, 1990

General
=======

This program was written in 'C' using Microsoft Quick C version 2.01, with
Quick Assembler.  The only part written in assembly language is the interrupt
driver for the serial port.  Quick C is OK, and it's certainly a good package
for the price, but I would suggest that for real commercial development the full
Microsoft C compiler should be used, along with a good hardware debugger such as
the Atron breakpoint board.  This really simplifies catching hard-to-find bugs
like null pointer accesses.

Assembler
=========

The assembler (ASM Command) is implemented by a mini-interpreter, which
reads text strings of parsing commands stored in memory, to determine
how to parse the user's input.  These commands are stored in the
structure "match".  This structure contains two strings, "in" and "out".
When the user types an assembly language instruction, the function
"sasm" is called to parse it.  "sasm" reads commands from the "in"
string to parse the user's input.  In doing so, the mini-commands in
that string store information in a set of long variables (array
"fields");  the commands in the "in" string really form a parsing
specification for the assembly language instruction, and if "sasm" gets
to the end of that string without detecting an error, then a
syntactically correct instruction was typed by the user, and it reads
commands from the "out" string to generate the associated opcodes, using the
information set up in the fields array.

All that remains, then, is to determine the correct series of
mini-commands to parse each instruction in the 68332's instruction set,
allowing for all the different legal addressing modes, and we have an
assembler!  Well it's not quite that easy, as the 332 has a huge
instruction set with lots of addressing modes.  Luckily it's very
orthogonal and we can encode the addressing modes as a set of
mini-command "subroutines", calling them at the appropriate point in the
parsing of an instruction.  The structure "substrings" contains sets of
specifications for the legal combinations of addressing modes (eg source
modes, destination modes, data modes, control modes, etc).

The 0th, and first elements of the "fields" array have pre-defined
information;  the 0th element contains the value of the assembler
program counter, and the 1st element contains a value called the
"current variable".  Some commands in the interpreter language, if not
given a variable specifier, will operate on the array entry specified by
the contents of the 1st element.  (Think of it as acting as a crude
index register!)

Parser Commands
===============

A command string is defined as a series of "blocks" to be executed by
the parser.  A block consists of a command, optionally followed by an
asterisk and a single numeric digit.  This "asterisk digit" specifies a
repetition count for the preceding block.  Several blocks may be grouped
together using parentheses "()";  if this is done, the blocks within the
parentheses are treated as a single block by the parser.

A block may be either a "non-special" character, in which case the text typed
by the user must match the character; or it may be a special character,
which tells the parser that some special action is required beyond
simple character comparision.  The default action of the parser is to
simply match input text against that stored in the command string;
however some characters in the command string have special meaning.
Some of these are listed below.

<block> Angle brackets signify that the block contained within is
optional but not required, to satisfy the parsing spec.  If the block
matches, then the parser will continue at the current point in the input
text;  if the block is not matched, the parser will continue with the
intput text at the point at which the optional block was encountered,
executing the first block after the closing ">" angle bracket.

[string]        Square brackets surround a set of characters which will
be compared against the current character in the input text;  if a
character in the string matches, the offset of that character from the
first within the string is stored in the current variable.  This is handy
for testing for byte, word, or long size specifiers in the instruction;
the spec
        <.[BWL]>
will test for a period followed by a "B","W", or "L" after the
instruction.  If a "L" was specified, then the number 2 will be stored
in the variable specified in fields [1].  If a "W" was specified, the
number stored would be 1, and so on.

(block block block)
        The parentheses group blocks together into a single block as
        described earlier.

%       The percent character specifies a number of special math, data
movement, and matching functions, as listed below.


Percent commands
================
general form:
%[<param1>[,<param2>]]<command>

param1 and param2 are decimal numeric constants; negative numbers are ok
param2 may be absent; if so, the function will use the current variable
(pointed to by fields [1]) in its place

commands:
a       add param1 to fields [param2].  If param2 is not specified then use
	the current variable instead.

c       returns the size code of fields [param1] into fields [param2]; the
	value will be 0, 1, or 2 indicating that a byte, word, or long word
	size is required to store the data.  If no param2 is given, the result
	is stored into the current variable.

d       format field data to output the extension words for the displacement
	addressing modes.  Param1 specifies the starting field containing the
	output data.  The data is laid out as follows:
	offset  info
	0       mode
	1       base register
	2       displacement
	3       1 for address reg index, 0 for data reg index
	4       index register no
	5       1 for long index, 0 for word index

	7       1 to suppress base register
	8       1 to suppress index register
	9       scale value (0-3 representing 1,2,4 or 8)

	The fields are left in the following format:
	offset  info
	0       1 for full format, 0 for brief format
	1       displacement size code (0:1 - null, 1:0 - word, 1:1 - long)
	2       displacement
	3       1 for address index reg, 0 for data index reg
	4       index reg number
	5       1 for long index no, 0 for word index no

	7       1 to suppress base register
	8       1 to suppress index register
	9       scale value (0-3 representing 1,2,4 or 8)

e       parse an expression and put the result in the current variable.
        Currently an expression may only consist of a hexadecimal constant.

g       stores param1 into fields [param2].  If param2 is not specified the
	current variable is used.

m       match the input text to the [param1] element of the structure
        "substrings".  The "before" element of the "substrings" entry will
        be executed; then the current variable is zeroed, and each
        string contained in that entry will be scanned against the input
        text for a match.  When a match occurs, the number of the
	matching string is added to the current variable and the after
        component of that substring entry is scanned.

p       moves fields [param1] into fields [param2].  If param2 is not
	specified the current variable is used.

q       quit interpretation of the command string.  Param1 is used as a return
	value.  Non-zero means no error occurred; zero means an error was
	detected, and the interpreter will treat the string as if no match
	occurred.

s       return the value of the symbol in the text.  This is currently a
        no-op, but is defined for possible future extension to allow symbolic
        debug capability.

x       execute a substring in the array outsubs
	if param1 is <= the number of fields, the string to be executed is
	contained in fields [param1]; otherwise execute substring (param1-30)

' ' (space)     match and skip past zero or more white space characters

?       if fields [param1] is non-zero, execute the following block,
        else skip it

=       if fields [param2] is equal to param1, then the following block
        is executed, otherwise it is skipped.

+,-,>,<,&,~,|,^,%,/
	execute the specified operator on fields [param1] and fields [param2],
	placing the result in fields [param2].  This is done as if the C
	expression "fields [param2] = fields [param2] <op> fields [param1]" were
	executed.  If param2 is not specified the current variable is used
	instead. < and > mean left and right shift; the others match the
	meaning used in the C language.  '~' is a unary operator and ignores
	param2.

!       the match status of the following block is inverted; that is, if there
	is a match when that block is scanned, the interpreter will act as if
	no match was made, and vice versa.  This is useful for scanning for
	text which must not contain some sequence, eg (An) without the trailing
	'+' indicates address register direct mode.

\       sign extend fields [param2] to size code (param1).  If param2 not
	specified then the current variable is operated upon.  Valid size
	codes are 1 (extend byte to word) and 2 (extend word to long).  It
	is important to remember that C requires two '\' characters!

When outputting opwords to memory, a simple method is needed for
specifying bit fields in the op words.  The output spec string "out"
allows the programmer to use the digits '1' and '0' to output binary
values to memory, or to use a letter to specify which element of the
"fields" array to use for binary output.  For example, the letter 'h'
specifies fields [7].  if the string
        hhhh
was included in the output spec, then the four least significant bits of
fields [7] would be output to memory.  Full op words may be built up
through combinations of fields [] data and fixed 0 and 1 bits.  An
example might be

        1100ddd100001ccc

which is the opword pattern for the "ABCD Dy,Dx" instruction.  In this
case, it is assumed that fields [2] contains the number of the "Dy"
register, while fields [3] contains the register number representing
"Dx".  By inserting a string of 'd's and 'c's among the fixed 1 and 0
values, the correct opword is generated.

One other feature is that the current variable (index value contained in
fields [1]) may be specified by using a period.

For more examples, check the array "outsubs", which contains many
output subroutines, called with the "%nx" command.

Below is a reference table of letter code versus fields [] index.

Variable no. vs. name
a b c d e f g h i j k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25


Disassembler
============

The disassembler is similiar in approach to, although simpler than, the
assembler.  In the file DIDASM.C, the structure ops [] contains an "in"
string and an "out" string for each legal binary op word.  The routine
parsebit () scans the "in" string, matching bits in memory against the
values specified in the string.  If a "0" or "1" is encountered in the
"in" string, then that exact value must b found in the corresponding bit
position in memory.  If a letter is found, then that letter specifies an
element of the fields [] array, and the corresponding bits are collected
from program memory and stored in the specified fields [] element.  This
provides a simple means of retrieving the value of bit fields in the op
word.

If parsebit () gets through the "in" string without a mismatch, then the
commands in the corresponding "out" string are executed.  The command
set is fairly limited here as compared to the assembler.  The normal
function is to output the characters in the "out" string to the display.
If a percent (%) character is encountered, then zero, one, or two
numeric digits of parameter information is gathered, and then a letter
specifies the function to be performed.  The table below lists all the
functions implemented.

General Form - % <param1> <param2> <letter>
param1 and param2 are a single digit.  One or both may be optional
depending on the particular function.

letters
=======

a       the addressing mode, specified by the contents of fields
[param1] (mode number) and fields [param2] (register number), is
displayed.  Any extension opwords or immediate data required to display
the mode will be retrieved from memory.

c       display the name of the condition code specified by fields [param1].

d       display the contents of fields [param1] in hex.  If param1 is
absent then the contents of memory at the current disassembly program
counter are displayed in hex.  The size code of the instruction must
have been previously specified using the %s command.

g       the immediate data at the disassembly program counter will be
retrieved.  If param1 is specified, the data retrieved will be stored in
fields [param1].  If param2 is also specified, then param1 is the size
code (0-2 for byte, word, or long data) and param2 specifies the element
of fields [] in which the data will be stored.

l       the word data at the disassembly pc in memory is used to
generate a register list for the MOVEM instruction.  Param1 is non-zero
for MOVEM to memory, or zero for MOVEM from memory.

p       the contents of fields [param1] are displayed in hex.

r       a relative branch address calculation is performed and the
resulting address (the target of the branch) is printed on the screen in
hex.  The three different branch modes (short, word, long) are
supported.

s       if param1 is specified, then fields [param1] is marked as the
element containing the size code for the instruction being disassembled.
The code should be 0,1, or 2 for byte, word, or long instructions.  If
param1 is absent then a text string ".B", ".W", or ".L" will be printed
depending on the contents of the marked fields [] element.

u	the field specified by the parameter is displayed as a hex digit;
	no check is performed in the symbol table for a symbol with the
	same value.

v       the param1 value is written into fields [param2].

Suggested Enhancements for BD32
================================

Listed below are several changes which will probably be desireable for a
commercial product.

Screen I/O
==========
The Screen I/O driver is very crude at the moment,  and it would be a good
idea to re-write it to call the IBM BIOS directly.  This will speed it up and
also eliminate the problem where PC-DOS will abort the program if the user
types control-C.  Aborting the program in this way is dangerous because it
leaves the serial port set up to generate interrupts, with the vector
pointing to BD32's driver which is sitting in now-deallocated memory.  Bad
scene!  This leads to mysterious system crashes and unhappy users.

Another reason to re-write the screen driver is to allow a status line at the
bottom of the screen.  Now instead of showing the 332's status on the BD32
command line prompt, it can be displayed and continuously updated on this
status line.

PC-DOS 'Critical Error' Handler (Int 24)
========================================

A handler should be installed, using Quick C's 'harderr' library routine, to
deal with common DOS errors such as drive not ready, printer out of paper,
etc.  This is important because the default DOS handler allows the user to
abort to DOS, without returning to BD32.  This will cause the same situation
as described above, leaving the serial port drivers in deallocated memory.

DI Command Protocol
===================

Long-term, the protocol between the PC and the DI board should be changed to
something that makes more efficient use of the serial port's limited
bandwidth.  The S-record format is a good place to start;  why not define
other types of records to do different things?  For example, S4 might down
load values into the cpu's registers rather than memory, with the address
field of the record specifying which register to start with.  Perhaps S5
could be a status command, with some data bytes in the record specifying
the exact function to perform, such as reset cpu, trace, return FREEZE/HALT/
RESET, etc.  Others could be defined to command the DI board to upload a
block of memory, etc.  S records are nice because we already use them all
over the place, and it includes checksum error checking as part of the format.
Using hex characters after the 'S', up to 16 different 'S' commands could
be defined which should be plenty.

Suggested Assembler Enhancements
================================

One of the things which I don't like about the assembler is its error
handling.  Right now if it doesn't find a matching instruction in its table,
the assembler simply tells you 'no match'.  Not very friendly.  I would suggest
that it be enhanced in one of two ways:

- split the specifications 'asmtable' into three parts, one for instruction,
  one for operands, and one for the output spec.  If an instruction was not
  matched in the table, the scanner would then be able to tell the user
  whether it was the instruction or the operand which was the problem.  This
  would also allow a hash table to be generated to speed up matching, although
  I believe it is fast enough already for a line-by line assembler.

- print the input line, and on the next line print an up-arrow (^) under the
  position pointed to by the scanning pointer asmin (in function sasm).  This
  will show the user where the problem is in the line that he just typed.

It might also be a good idea to expand the assembler's handling of indexed
addressing modes.  Right now the only syntax it handles is the offset(An,Xn.S)
form (ie, offset outside the parentheses, base register and index register
inside the parentheses).  It seems that it is common for 68K assemblers to
also accept the form where the offset is inside the parentheses with the
registers, ie (offset,An,Xn.S).
